package com.ironman.ma;

import org.apache.log4j.Logger;

import java.util.*;

/**
 * Hello world!
 */
public class App {
    private static final Logger log = Logger.getLogger(App.class);

    public static void goodLog() {
        log.info("testing goodLog");
    }

    public static void badLog() {
        log.error("testing badLog");
    }

    public static void realBadLog() {
        try {
            throw new RuntimeException();
        } catch (RuntimeException ex) {
            log.error("testing realBadLog " + ex.getMessage(), ex);
        }
    }

    public static void main2(String[] args) throws InterruptedException {
        System.out.println("Hello World!");

        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        input.close();
        log.info("testing main");
        for (int i = 0; i < 2; i++) {
            goodLog();
            Thread.sleep(1000);
            badLog();
            Thread.sleep(1000);
            realBadLog();
            Thread.sleep(1000);
        }
        goodLog();
    }

    public static void leftshift(int i, int j) {
        i <<= j;
        System.out.println(i);
    }

    public static void main3(String args[]) {
        int i = 4, j = 4;
        leftshift(i, j);
        System.out.println(i);
        int k[] = {1, 2};
    }

    public static int repeatedNumber(int[] a) {
        if (a == null || a.length <= 1) {
            return -1;
        }
        int sqrt = (int) Math.sqrt(a.length - 1);
        int buckets = (int) Math.ceil(a.length / sqrt);


        if (buckets * sqrt < a.length) {
            sqrt++;
        }

        int burr_bucket_size = a.length - (buckets - 1) * sqrt;

        HashSet<Integer> maxKeys = new HashSet<Integer>();

        HashMap<Integer, Integer> countMap = new HashMap<Integer, Integer>();
        int maxKey = 0;

        for (Integer node : a) {
            int key = (int) ((node - 1) / sqrt);
            if (countMap.containsKey(key)) {
                int newCount = countMap.get(key) + 1;
                countMap.put(key, newCount);
            } else {
                countMap.put(key, 1);
            }
            if (key > maxKey) {
                maxKey = key;
            }
        }

        for (Map.Entry<Integer, Integer> e : countMap.entrySet()) {
            if (e.getValue() > sqrt) {
                maxKeys.add(e.getKey());
            }
        }
        maxKeys.add(maxKey);
        System.out.println("sqrt :" + sqrt + ", lookup:" + maxKeys.size() + ", act:" + countMap.size());
        countMap = new HashMap<Integer, Integer>();
        for (Integer node : a) {
            int key = (int) ((node - 1) / sqrt);
            if (maxKeys.contains(key)) {
                if (countMap.containsKey(node)) {
                    return node;
                } else {
                    countMap.put(node, 1);
                }
            }
        }
        return -1;
    }

    public static int repeatedNumberNew(List<Integer> a) {

        HashMap<Integer, Integer> occu = new HashMap<Integer, Integer>();
//        occu.put(a.get(0),1);
//        if(a.get(0)==a.get(1)){
//            occu.put(a.get(0),2);
//        }else{
//            occu.put(a.get(1),1);
//        }
        int tg = a.size();
        for (int i = 0; i < a.size(); i++) {
            if (occu.size() == 2 && !occu.containsKey(a.get(i))) {
                HashMap<Integer, Integer> occuNew = new HashMap<Integer, Integer>();
                for (Map.Entry<Integer, Integer> e : occu.entrySet()) {
                    if (e.getValue() != 1) {
                        occuNew.put(e.getKey(), e.getValue() - 1);
                    }
                }
                occu = occuNew;
            } else {
                if (occu.containsKey(a.get(i))) {
                    occu.put(a.get(i), occu.get(a.get(i)) + 1);
                } else {
                    occu.put(a.get(i), 1);
                }
            }

        }

        for (Map.Entry<Integer, Integer> e : occu.entrySet()) {
            occu.put(e.getKey(), 0);
        }

        for (int i = 0; i < a.size(); i++) {
            if (occu.containsKey(a.get(i))) {
                occu.put(a.get(i), occu.get(a.get(i)) + 1);
            }
        }

        for (Map.Entry<Integer, Integer> e : occu.entrySet()) {
            if (e.getValue() > a.size() / 3) {
                System.out.println(e.getKey() + ", " + e.getValue() + ", " + occu.size());
                return e.getKey();
            }
        }
        return -1;
    }

    public static int repeatedNumber(List<Integer> a) {


        HashMap<Integer, Integer> occu = new HashMap<Integer, Integer>();
        int iter = 0;
        int sumOccu = 0;
        int maxOccu = 0;
        int maxOccuKey = 0;
        while (iter < a.size() && occu.size() < 2) {
            if (occu.containsKey(a.get(iter))) {
                occu.put(a.get(iter), occu.get(a.get(iter)) + 1);
            } else {
                occu.put(a.get(iter), 1);
            }
            if (occu.get(a.get(iter)) > maxOccu) {
                maxOccu = occu.get(a.get(iter));
                maxOccuKey = a.get(iter);
            }
            sumOccu++;
            iter++;
        }
        int actLen = a.size();
        for (int i = iter; i < a.size(); i++) {
            if (maxOccu > actLen / 3) {
                return maxOccuKey;
            }

            if (occu.size() == 2 && !occu.containsKey(a.get(i))) {
                // fresh stuff
                actLen = actLen - sumOccu;
                occu = new HashMap<Integer, Integer>();
                sumOccu = 0;
                maxOccu = 0;
                maxOccuKey = 0;
            } else {
                if (occu.containsKey(a.get(i))) {
                    occu.put(a.get(i), occu.get(a.get(i)) + 1);
                } else {
                    occu.put(a.get(i), 1);
                }
                if (occu.get(a.get(i)) > maxOccu) {
                    maxOccu = occu.get(a.get(i));
                    maxOccuKey = a.get(i);
                }
                sumOccu++;
            }

        }


        return maxOccuKey;


    }

    public static void main4(String[] args) {
//        System.out.println(repeatedNumber(new int[]{ 1,3,1,3,5,5 }));
//        System.out.println(repeatedNumber(new int[]{ 352, 672, 376, 701, 777, 382, 14, 905, 896, 853, 133, 199, 594, 339, 597, 642, 391, 578, 663, 922, 714, 236, 90, 839, 686, 844, 553, 372, 99, 677, 498, 920, 294, 493, 112, 380, 638, 118, 799, 627, 774, 645, 450, 143, 355, 548, 266, 45, 749, 832, 680, 976, 430, 656, 583, 153, 607, 509, 640, 393, 978, 792, 207, 211, 755, 831, 525, 598, 186, 673, 373, 357, 881, 159, 736, 814, 367, 25, 23, 280, 46, 874, 34, 849, 142, 851, 412, 136, 497, 696, 71, 557, 329, 953, 760, 24, 148, 267, 907, 841, 55, 706, 127, 734, 480, 369, 968, 982, 233, 872, 256, 183, 169, 711, 460, 763, 658, 724, 890, 985, 293, 341, 639, 554, 154, 869, 314, 165, 437, 198, 731, 13, 623, 505, 622, 951, 426, 779, 786, 146, 349, 586, 75, 379, 489, 899, 620, 816, 817, 191, 931, 662, 137, 520, 503, 685, 970, 843, 7, 966, 100, 518, 415, 491, 229, 204, 163, 747, 813, 336, 492, 514, 98, 390, 319, 551, 364, 770, 974, 506, 921, 387, 59, 616, 278, 370, 781, 875, 413, 918, 248, 519, 568, 894, 944, 757, 47, 679, 775, 396, 591, 842, 150, 532, 108, 6, 715, 44, 963, 688, 362, 219, 85, 175, 157, 660, 632, 97, 247, 795, 64, 927, 618, 516, 870, 259, 48, 479, 681, 285, 313, 422, 264, 1, 767, 79, 740, 448, 317, 808, 409, 628, 864, 523, 192, 342, 975, 29, 227, 18, 452, 196, 330, 709, 898, 3, 499, 789, 811, 728, 187, 888, 126, 802, 402, 431, 987, 912, 424, 960, 283, 257, 289, 324, 629, 268, 68, 695, 122, 5, 185, 32, 274, 821, 473, 825, 284, 833, 661, 671, 850, 819, 152, 678, 576, 375, 971, 123, 290, 404, 41, 457, 746, 552, 592, 42, 216, 195, 531, 130, 345, 331, 39, 353, 174, 299, 113, 643, 481, 145, 205, 444, 417, 67, 167, 129, 272, 474, 54, 561, 858, 541, 901, 536, 626, 347, 549, 60, 577, 946, 882, 392, 27, 788, 361, 739, 986, 559, 665, 406, 464, 453, 360, 125, 803, 759, 254, 346, 772, 172, 458, 451, 619, 737, 343, 212, 651, 848, 502, 161, 155, 495, 116, 631, 447, 425, 590, 790, 366, 80, 483, 22, 550, 528, 754, 648, 262, 877, 748, 582, 587, 756, 292, 572, 726, 66, 270, 949, 933, 698, 823, 621, 171, 332, 141, 593, 866, 515, 162, 952, 189, 318, 962, 904, 720, 385, 664, 965, 297, 617, 333, 49, 744, 221, 916, 252, 959, 384, 718, 793, 477, 210, 56, 908, 555, 435, 322, 484, 636, 723, 132, 190, 263, 276, 581, 653, 579, 895, 234, 806, 407, 378, 794, 533, 106, 649, 556, 15, 177, 243, 4, 589, 69, 787, 144, 231, 418, 547, 110, 751, 540, 919, 710, 837, 261, 782, 838, 494, 769, 193, 403, 732, 852, 574, 937, 567, 702, 251, 308, 468, 398, 111, 566, 633, 634, 356, 961, 158, 834, 941, 542, 96, 334, 354, 964, 868, 980, 529, 539, 917, 50, 89, 138, 102, 545, 810, 742, 109, 273, 879, 762, 707, 603, 121, 215, 863, 53, 758, 610, 605, 741, 83, 170, 929, 650, 43, 351, 703, 897, 924, 368, 513, 630, 250, 176, 527, 753, 306, 359, 218, 796, 958, 504, 432, 93, 906, 181, 383, 194, 773, 388, 857, 223, 859, 500, 829, 309, 149, 377, 855, 488, 389, 264, 915, 286, 725, 275, 826, 203, 208, 563, 668, 588, 401, 325, 780, 443, 939, 37, 19, 134, 575, 928, 862, 73, 768, 131, 217, 508, 178, 200, 722, 31, 328, 955, 573, 20, 445, 704, 727, 104, 517, 84, 778, 956, 891, 655, 584, 733, 925, 510, 386, 889, 265, 61, 684, 340, 363, 913, 429, 11, 454, 244, 783, 253, 940, 321, 344, 699, 822, 300, 865, 124, 226, 761, 785, 666, 462, 78, 675, 693, 399, 717, 101, 537, 95, 302, 57, 596, 562, 33, 10, 419, 472, 214, 611, 538, 676, 77, 180, 471, 670, 669, 114, 560, 2, 697, 973, 467, 94, 139, 602, 854, 861, 312, 893, 147, 335, 613, 950, 463, 938, 348, 395, 988, 374, 311, 752, 690, 522, 835, 776, 337, 140, 860, 608, 910, 209, 281, 948, 239, 242, 887, 350, 466, 249, 738, 303, 440, 809, 646, 271, 323, 564, 967, 433, 683, 485, 708, 647, 295, 791, 74, 58, 721, 449, 687, 476, 625, 526, 279, 674, 240, 766, 487, 657, 86, 654, 225, 277, 237, 428, 421, 926, 52, 235, 784, 615, 197, 934, 400, 92, 222, 827, 764, 9, 420, 569, 689, 461, 867, 255, 932, 624, 969, 807, 184, 743, 486, 459, 652, 394, 107, 812, 12, 475, 81, 103, 168, 8, 609, 72, 507, 830, 63, 36, 105, 438, 241, 836, 606, 876, 935, 423, 878, 801, 892, 228, 269, 972, 705, 692, 17, 558, 76, 840, 416, 246, 35, 26, 182, 135, 288, 947, 580, 117, 441, 713, 188, 478, 745, 232, 936, 871, 923, 712, 408, 521, 316, 804, 414, 828, 410, 883, 599, 930, 213, 903, 224, 326, 88, 245, 957, 614, 436, 16, 914, 456, 612, 496, 120, 310, 156, 637, 805, 358, 983, 635, 534, 644, 298, 884, 730, 943, 91, 179, 230, 765, 981, 291, 65, 411, 820, 846, 845, 320, 911, 873, 511, 524, 942, 397, 151, 979, 909, 886, 62, 442, 282, 900, 501, 38, 296, 202, 446, 338, 87, 880, 716, 771, 128, 115, 427, 750, 667, 604, 470, 70, 694, 719, 600, 512, 287, 984, 902, 164, 238, 30, 220, 28, 885, 659, 798, 682, 641, 729, 544, 482, 439, 945, 601, 258, 381, 455, 82, 815, 206, 847, 824, 371, 490, 700, 434, 585, 365, 797, 546, 571, 570, 735, 201, 405, 315, 818, 304, 977, 166, 21, 40, 469, 595, 535, 173, 119, 51, 307, 856, 260, 305, 543, 530, 465, 800, 691, 327, 565, 954, 160, 301 }));
//        System.out.println(repeatedNumber(new int[]{ 247, 240, 303, 9, 304, 105, 44, 204, 291, 26, 242, 2, 358, 264, 176, 289, 196, 329, 189, 102, 45, 111, 115, 339, 74, 200, 34, 201, 215, 173, 107, 141, 71, 125, 6, 241, 275, 88, 91, 58, 171, 346, 219, 238, 246, 10, 118, 163, 287, 179, 123, 348, 283, 313, 226, 324, 203, 323, 28, 251, 69, 311, 330, 316, 320, 312, 50, 157, 342, 12, 253, 180, 112, 90, 16, 288, 213, 273, 57, 243, 42, 168, 55, 144, 131, 38, 317, 194, 355, 254, 202, 351, 62, 80, 134, 321, 31, 127, 232, 67, 22, 124, 271, 231, 162, 172, 52, 228, 87, 174, 307, 36, 148, 302, 198, 24, 338, 276, 327, 150, 110, 188, 309, 354, 190, 265, 3, 108, 218, 164, 145, 285, 99, 60, 286, 103, 119, 29, 75, 212, 290, 301, 151, 17, 147, 94, 138, 272, 279, 222, 315, 116, 262, 1, 334, 41, 54, 208, 139, 332, 89, 18, 233, 268, 7, 214, 20, 46, 326, 298, 101, 47, 236, 216, 359, 161, 350, 5, 49, 122, 345, 269, 73, 76, 221, 280, 322, 149, 318, 135, 234, 82, 120, 335, 98, 274, 182, 129, 106, 248, 64, 121, 258, 113, 349, 167, 192, 356, 51, 166, 77, 297, 39, 305, 260, 14, 63, 165, 85, 224, 19, 27, 177, 344, 33, 259, 292, 100, 43, 314, 170, 97, 4, 78, 310, 61, 328, 199, 255, 159, 185, 261, 229, 11, 295, 353, 186, 325, 79, 142, 223, 211, 152, 266, 48, 347, 21, 169, 65, 140, 83, 156, 340, 56, 220, 130, 117, 143, 277, 235, 59, 205, 153, 352, 300, 114, 84, 183, 333, 230, 197, 336, 244, 195, 37, 23, 206, 86, 15, 187, 181, 308, 109, 293, 128, 66, 270, 209, 158, 32, 25, 227, 191, 35, 40, 13, 175, 146, 299, 207, 217, 281, 30, 357, 184, 133, 245, 284, 343, 53, 210, 306, 136, 132, 239, 155, 73, 193, 278, 257, 126, 331, 294, 250, 252, 263, 92, 267, 282, 72, 95, 337, 154, 319, 341, 70, 81, 68, 160, 8, 249, 96, 104, 137, 256, 93, 178, 296, 225, 237 }));
//        System.out.println(repeatedNumber(new int[]{ 442, 249, 406, 112, 202, 98, 228, 99, 38, 10, 402, 505, 104, 340, 265, 317, 190, 403, 148, 276, 145, 199, 456, 489, 237, 226, 470, 342, 405, 339, 142, 234, 542, 96, 71, 297, 261, 262, 130, 119, 428, 82, 432, 219, 430, 439, 188, 397, 227, 478, 400, 111, 451, 388, 34, 303, 158, 68, 74, 502, 36, 80, 243, 508, 73, 324, 103, 325, 46, 211, 133, 144, 480, 404, 231, 416, 401, 370, 3, 48, 407, 195, 212, 300, 47, 409, 44, 21, 248, 105, 56, 319, 117, 149, 334, 455, 544, 429, 464, 143, 75, 197, 316, 292, 352, 282, 525, 194, 87, 242, 283, 333, 356, 440, 338, 100, 366, 368, 520, 129, 479, 499, 408, 496, 307, 173, 347, 101, 293, 523, 114, 5, 393, 178, 329, 394, 302, 59, 492, 175, 537, 538, 454, 217, 84, 344, 126, 360, 471, 433, 238, 465, 62, 165, 43, 139, 530, 512, 280, 312, 518, 385, 8, 29, 93, 467, 320, 64, 120, 452, 391, 358, 522, 445, 274, 240, 172, 449, 205, 18, 328, 453, 278, 536, 69, 331, 166, 92, 50, 462, 501, 27, 106, 72, 30, 11, 289, 318, 343, 245, 497, 411, 218, 363, 151, 85, 37, 337, 285, 511, 137, 426, 155, 254, 376, 136, 235, 90, 418, 60, 487, 181, 232, 486, 287, 515, 362, 86, 395, 255, 159, 527, 336, 378, 375, 115, 15, 179, 33, 67, 177, 247, 51, 424, 284, 357, 157, 162, 253, 135, 216, 122, 41, 118, 359, 209, 355, 373, 437, 23, 214, 97, 191, 447, 83, 267, 256, 20, 52, 236, 39, 259, 204, 353, 510, 55, 203, 305, 290, 206, 413, 488, 14, 380, 174, 540, 299, 463, 485, 371, 309, 186, 481, 192, 200, 156, 288, 534, 475, 382, 184, 152, 220, 189, 521, 443, 110, 160, 369, 171, 183, 468, 65, 108, 427, 423, 516, 146, 384, 138, 222, 35, 365, 163, 458, 132, 498, 372, 66, 345, 326, 396, 40, 141, 22, 491, 19, 286, 415, 434, 121, 1, 270, 313, 78, 446, 379, 392, 31, 9, 180, 420, 45, 76, 26, 460, 49, 89, 279, 54, 57, 208, 519, 241, 275, 386, 441, 533, 296, 507, 422, 109, 196, 361, 2, 4, 474, 182, 53, 310, 414, 291, 364, 61, 535, 398, 134, 24, 509, 335, 484, 263, 476, 154, 304, 25, 306, 444, 32, 266, 210, 539, 473, 322, 7, 466, 529, 436, 350, 494, 16, 161, 116, 459, 168, 301, 215, 213, 91, 438, 102, 224, 277, 13, 17, 28, 258, 70, 531, 541, 532, 315, 187, 381, 170, 272, 147, 223, 252, 421, 81, 271, 201, 164, 176, 58, 257, 321, 95, 377, 472, 113, 94, 457, 153, 469, 225, 140, 399, 281, 308, 230, 193, 390, 514, 483, 412, 327, 12, 543, 367, 493, 504, 419, 524, 198, 77, 295, 417, 389, 374, 435, 42, 330, 528, 311, 490, 387, 341, 517, 127, 298, 169, 185, 125, 233, 410, 477, 128, 239, 107, 448, 354, 221, 425, 264, 294, 323, 88, 526, 124, 351, 349, 506, 150, 348, 246, 482, 260, 251, 167, 503, 250, 268, 273, 207, 540, 332, 63, 431, 131, 383, 6, 495, 244, 346, 269, 79, 450, 513, 123, 461, 314, 229, 500 }));
//        System.out.println(repeatedNumber(new int[]{ 26, 307, 10, 410, 143, 118, 262, 6, 231, 175, 394, 2, 359, 408, 455, 13, 430, 412, 94, 121, 41, 63, 330, 165, 240, 169, 230, 99, 221, 192, 461, 313, 70, 427, 462, 30, 125, 133, 297, 187, 102, 74, 318, 375, 241, 22, 149, 259, 217, 226, 134, 148, 238, 440, 166, 28, 459, 306, 197, 454, 256, 389, 194, 248, 180, 456, 321, 279, 120, 250, 300, 355, 183, 272, 465, 27, 209, 327, 407, 122, 222, 308, 334, 200, 154, 91, 116, 263, 11, 83, 172, 98, 283, 301, 444, 173, 213, 25, 471, 144, 324, 368, 233, 317, 373, 108, 382, 176, 413, 384, 190, 17, 360, 388, 354, 448, 340, 24, 419, 184, 296, 177, 78, 128, 56, 329, 31, 428, 434, 285, 381, 42, 159, 9, 458, 7, 365, 357, 65, 281, 275, 326, 32, 377, 205, 109, 247, 87, 258, 163, 364, 290, 406, 39, 171, 282, 291, 168, 29, 193, 452, 111, 114, 44, 268, 335, 174, 356, 64, 202, 270, 372, 370, 131, 276, 343, 431, 81, 249, 350, 104, 361, 390, 331, 369, 254, 14, 442, 284, 401, 400, 351, 84, 242, 203, 214, 93, 3, 89, 72, 223, 110, 208, 105, 12, 52, 265, 179, 80, 86, 246, 195, 438, 198, 245, 251, 61, 311, 469, 219, 328, 145, 371, 404, 338, 228, 366, 309, 420, 271, 453, 395, 48, 67, 69, 4, 399, 435, 127, 425, 264, 45, 55, 376, 123, 54, 220, 403, 432, 161, 261, 137, 8, 40, 423, 337, 53, 422, 146, 38, 457, 255, 433, 378, 449, 320, 88, 312, 139, 156, 295, 260, 164, 349, 23, 58, 464, 426, 117, 273, 162, 186, 135, 447, 446, 387, 348, 392, 158, 79, 322, 196, 160, 346, 323, 362, 82, 90, 253, 286, 85, 49, 472, 278, 141, 374, 358, 129, 18, 126, 150, 299, 339, 142, 298, 269, 274, 46, 352, 51, 439, 34, 237, 396, 235, 185, 393, 191, 211, 383, 115, 224, 289, 106, 101, 216, 33, 207, 347, 20, 76, 421, 170, 363, 188, 310, 332, 302, 316, 201, 325, 189, 379, 73, 397, 152, 468, 96, 418, 303, 236, 443, 100, 68, 60, 470, 305, 345, 37, 252, 445, 409, 277, 405, 391, 292, 19, 36, 314, 424, 119, 167, 257, 304, 95, 206, 181, 319, 62, 293, 429, 451, 287, 35, 467, 353, 441, 97, 178, 463, 212, 336, 147, 132, 288, 136, 239, 77, 57, 414, 280, 266, 315, 210, 267, 50, 21, 244, 415, 386, 229, 157, 243, 398, 232, 130, 215, 138, 344, 218, 124, 402, 15, 341, 107, 92, 17, 103, 153, 227, 417, 385, 411, 416, 75, 234, 380, 43, 450, 1, 112, 151, 155, 66, 204, 367, 437, 342, 333, 466, 47, 71, 199, 16, 182, 140, 294, 59, 436, 225, 460, 113, 5 }));
//        System.out.println(repeatedNumber(new int[]{ 593,401,471,135,378,516,514,154,354,489,238,379,115,109,48,546,220,136,339,529,188,200,345,215,562,114,59,410,495,256,282,521,90,368,352,367,340,168,543,205,4,204,474,14,550,201,92,523,158,211,49,530,144,101,329,465,376,81,528,180,397,428,38,388,464,141,94,558,88,251,273,468,346,24,480,532,486,97,267,585,228,237,27,268,569,71,195,236,179,85,322,300,396,344,221,156,547,501,18,417,72,130,26,181,426,455,549,170,89,584,331,261,9,451,217,416,557,493,283,453,58,411,383,98,187,253,13,16,360,35,335,279,246,82,587,17,505,526,435,264,389,351,122,479,211,93,83,77,153,128,387,174,391,498,133,323,252,314,99,226,127,366,302,197,3,374,500,447,45,193,564,43,126,338,178,301,570,446,578,225,566,120,107,56,472,503,262,214,102,457,218,365,487,421,229,328,438,572,407,460,173,559,159,519,263,66,520,296,8,76,555,313,166,239,6,67,456,25,573,108,149,415,437,470,522,440,134,276,207,213,333,271,163,362,75,384,496,171,137,224,580,50,12,395,216,53,502,161,177,534,458,31,293,249,524,208,19,334,297,275,531,131,112,169,233,427,129,219,52,184,588,248,30,265,286,95,320,592,341,371,589,257,449,336,422,310,119,298,210,116,190,222,235,567,206,452,454,64,69,240,212,145,61,448,545,390,227,466,473,91,363,515,40,121,138,361,309,284,551,260,444,404,412,424,199,258,307,7,304,124,381,478,54,86,553,535,576,73,544,311,509,312,63,476,343,406,203,491,80,405,42,375,413,443,105,563,533,581,23,288,164,373,507,527,556,70,231,147,394,51,20,591,172,290,87,44,517,459,579,15,295,349,488,586,68,242,305,386,196,194,315,565,182,445,538,39,160,132,326,369,485,355,342,60,34,571,47,74,431,140,223,441,400,420,272,316,11,583,377,423,552,463,103,57,537,481,209,511,125,385,289,270,539,536,175,245,568,357,321,306,198,364,418,541,202,358,162,247,280,157,554,393,414,303,497,499,241,33,475,36,380,100,398,65,189,408,84,46,542,5,287,285,442,433,494,269,1,317,477,21,359,294,409,29,461,484,37,318,148,356,370,183,308,117,146,250,243,506,142,292,41,518,113,150,337,62,436,327,274,492,2,350,191,55,540,32,392,439,469,429,450,96,192,10,28,118,432,176,525,482,419,278,402,508,259,430,330,353,434,266,104,504,467,234,151,165,167,299,403,254,281,332,560,277,372,399,232,79,78,513,382,324,348,510,230,186,110,548,111,574,582,22,561,139,291,255,244,123,577,155,462,490,185,590,425,347,106,483,325,152,512,143,575,319 }));
//        System.out.println(repeatedNumber(new int[]{ 127, 228, 308, 341, 350, 371, 195, 11, 223, 138, 206, 279, 385, 289, 276, 152, 42, 208, 382, 22, 185, 339, 64, 149, 337, 122, 101, 15, 388, 205, 160, 35, 277, 240, 201, 302, 335, 336, 61, 236, 320, 200, 85, 44, 287, 164, 50, 366, 202, 301, 259, 89, 59, 113, 47, 248, 146, 71, 23, 373, 197, 39, 27, 381, 219, 253, 32, 386, 129, 105, 299, 296, 31, 110, 151, 191, 372, 395, 255, 257, 275, 77, 380, 226, 90, 251, 67, 281, 234, 9, 30, 216, 370, 1, 88, 107, 10, 368, 80, 119, 34, 325, 82, 328, 54, 319, 233, 66, 229, 209, 135, 98, 192, 331, 21, 125, 241, 297, 221, 194, 19, 369, 92, 290, 87, 384, 141, 41, 84, 224, 391, 324, 55, 145, 378, 214, 161, 347, 130, 48, 177, 365, 163, 17, 133, 210, 182, 361, 340, 49, 227, 131, 36, 353, 311, 225, 134, 243, 109, 115, 176, 284, 315, 26, 330, 262, 156, 304, 309, 323, 99, 108, 167, 343, 144, 148, 392, 118, 81, 37, 387, 374, 360, 332, 150, 171, 231, 18, 249, 126, 252, 327, 95, 172, 215, 184, 295, 103, 220, 293, 384, 16, 292, 354, 211, 396, 198, 5, 298, 286, 316, 2, 307, 389, 348, 269, 73, 159, 352, 212, 213, 139, 271, 52, 264, 28, 65, 8, 45, 40, 283, 3, 102, 246, 94, 181, 186, 305, 43, 303, 322, 199, 14, 143, 168, 280, 242, 128, 106, 291, 38, 137, 349, 51, 12, 123, 180, 154, 321, 165, 124, 356, 278, 183, 375, 100, 222, 114, 117, 136, 6, 326, 254, 68, 329, 270, 58, 69, 265, 394, 363, 310, 140, 204, 342, 364, 377, 258, 60, 261, 78, 312, 317, 196, 170, 20, 190, 33, 70, 238, 142, 333, 178, 346, 112, 96, 232, 235, 357, 285, 155, 169, 93, 79, 217, 174, 239, 207, 318, 193, 120, 104, 245, 189, 62, 268, 121, 294, 390, 218, 24, 306, 273, 367, 111, 76, 376, 344, 359, 355, 74, 116, 358, 237, 53, 166, 256, 338, 274, 300, 230, 175, 91, 46, 362, 147, 351, 72, 75, 97, 7, 345, 266, 263, 393, 25, 282, 244, 250, 83, 379, 57, 63, 314, 272, 86, 288, 157, 334, 132, 179, 383, 173, 260, 56, 267, 4, 188, 158, 313, 247, 187, 203, 13, 153, 29, 162 }));
//        List<Integer> ll = Arrays.asList(1000274, 1000802, 1000914, 1000847, 1000073, 1000562, 1000741, 1000802, 1000965, 1000371, 1000406, 1000441, 1000179, 1000802, 1000552, 1000802, 1000100, 1000724, 1000024, 1000134, 1000313, 1000802, 1000977, 1000777, 1000206, 1000412, 1000802, 1000570, 1000802, 1000518, 1000691, 1000959, 1000903, 1000802, 1000802, 1000273, 1000802, 1000802, 1000265, 1000706, 1000677, 1000802, 1000843, 1000802, 1000061, 1000802, 1000802, 1000975, 1000403, 1000150, 1000959, 1000889, 1000177, 1000416, 1000491, 1000177, 1000807, 1000989, 1000489, 1000447, 1000802, 1000860, 1000104, 1000802, 1000570, 1000015, 1000802, 1000802, 1000593, 1000802, 1000802, 1000326, 1000802, 1000802, 1000120, 1000772, 1000965, 1000802, 1000887, 1000802, 1000567, 1000973, 1000577, 1000820, 1000922, 1000802, 1000982, 1000525, 1000369, 1000829, 1000740, 1000159, 1000909, 1000510, 1000402, 1000802, 1000802, 1000239, 1000247, 1000328, 1000427, 1000802, 1000519, 1000296, 1000114, 1000149, 1000802, 1000802, 1000107, 1000841, 1000017, 1000909, 1000192, 1000425, 1000088, 1000077, 1000506, 1000163, 1000465, 1000626, 1000371, 1000802, 1000179, 1000306, 1000159, 1000802, 1000802, 1000848, 1000138, 1000306, 1000802, 1000881, 1000828, 1000802, 1000008, 1000802, 1000456, 1000802, 1000880, 1000579, 1000434, 1000163, 1000188, 1000802, 1000802, 1000231, 1000945, 1000802, 1000070, 1000727, 1000802, 1000802, 1000802, 1000051, 1000644, 1000802, 1000802, 1000057, 1000967, 1000802, 1000802, 1000366, 1000802, 1000485, 1000802, 1000061, 1000212, 1000192, 1000577, 1000559, 1000802, 1000189, 1000802, 1000802, 1000107, 1000177, 1000011, 1000802, 1000987, 1000400, 1000802, 1000402, 1000024, 1000009, 1000118, 1000046, 1000349, 1000250, 1000282, 1000138, 1000405, 1000295, 1000802, 1000878, 1000166, 1000802, 1000135, 1000005, 1000723, 1000491, 1000802, 1000802, 1000802, 1000802, 1000786, 1000306, 1000802, 1000802, 1000802, 1000639, 1000683, 1000880, 1000329, 1000408, 1000822, 1000947, 1000802, 1000455, 1000037, 1000311, 1000802, 1000802, 1000339, 1000802, 1000519, 1000401, 1000802, 1000256, 1000802, 1000802, 1000503, 1000802, 1000787, 1000802, 1000802, 1000384, 1000456, 1000845, 1000802, 1000802, 1000000, 1000213, 1000629, 1000802, 1000226, 1000802, 1000802, 1000107, 1000100, 1000802, 1000587, 1000882, 1000049, 1000623, 1000802, 1000178, 1000788, 1000648, 1000802, 1000567, 1000802, 1000802, 1000802, 1000085, 1000109, 1000965, 1000353, 1000802, 1000802, 1000802, 1000982, 1000663, 1000829, 1000578, 1000753, 1000802, 1000802, 1000529, 1000060, 1000047, 1000802, 1000750, 1000780, 1000277, 1000802, 1000751, 1000590, 1000802, 1000953, 1000240, 1000218, 1000659, 1000802, 1000001, 1000766, 1000802, 1000508, 1000802, 1000802, 1000802, 1000028, 1000802, 1000493, 1000077, 1000427, 1000505, 1000752, 1000802, 1000747, 1000126, 1000269, 1000297, 1000394, 1000257, 1000708, 1000802, 1000802, 1000697, 1000802, 1000802, 1000802, 1000921, 1000559, 1000450, 1000206, 1000802, 1000802, 1000149, 1000031, 1000866, 1000721, 1000497, 1000654, 1000057, 1000802, 1000130, 1000523, 1000577, 1000750, 1000536, 1000339, 1000796, 1000802, 1000802, 1000197, 1000584, 1000939, 1000802, 1000633, 1000553, 1000124, 1000086, 1000619, 1000802, 1000415, 1000802, 1000125, 1000802, 1000104, 1000348, 1000464, 1000187, 1000887, 1000369, 1000281, 1000802, 1000802, 1000526, 1000685, 1000029, 1000922, 1000191, 1000802, 1000802, 1000802, 1000298, 1000802, 1000176, 1000295, 1000802, 1000802, 1000238, 1000802, 1000802, 1000314, 1000303, 1000802, 1000698, 1000309, 1000677, 1000606, 1000802, 1000701, 1000898, 1000579, 1000990, 1000513, 1000435, 1000192, 1000960, 1000324, 1000509, 1000906, 1000802, 1000492, 1000705, 1000641, 1000479, 1000662, 1000642, 1000791, 1000942, 1000802, 1000802, 1000100, 1000296, 1000802, 1000802, 1000533, 1000802, 1000038, 1000802, 1000254, 1000802, 1000802, 1000802, 1000802, 1000393, 1000802, 1000435, 1000484, 1000802, 1000847, 1000802, 1000360, 1000961, 1000544, 1000914, 1000802, 1000802, 1000663, 1000802, 1000802, 1000519, 1000802, 1000928, 1000802, 1000802, 1000802, 1000802, 1000258, 1000108, 1000544, 1000802, 1000169, 1000097, 1000802, 1000306, 1000977, 1000802, 1000153, 1000802, 1000802, 1000039, 1000099, 1000802, 1000468, 1000862, 1000802, 1000802, 1000802, 1000068, 1000802, 1000161, 1000179, 1000710, 1000802, 1000802, 1000802, 1000802, 1000540, 1000802, 1000115, 1000802, 1000802, 1000089, 1000802, 1000798, 1000802, 1000802, 1000544, 1000979, 1000850, 1000085, 1000197, 1000802, 1000802, 1000031, 1000704, 1000515, 1000802, 1000198, 1000382, 1000597, 1000613, 1000857, 1000798, 1000319, 1000266, 1000154, 1000753, 1000017, 1000004, 1000802);
        List<Integer> ll = Arrays.asList(1000545, 1000038, 1000647, 1000038, 1000562, 1000038, 1000586, 1000487, 1000951, 1000226, 1000038, 1000145, 1000038, 1000761, 1000196, 1000038, 1000821, 1000829, 1000038, 1000570, 1000846, 1000038, 1000178, 1001000, 1000038, 1000568, 1000278, 1000734, 1000048, 1000038, 1000002, 1000271, 1000388, 1000315, 1000816, 1000038, 1000038, 1000846, 1000305, 1000853, 1000383, 1000116, 1000797, 1000279, 1000038, 1000038, 1000049, 1000108, 1000789, 1000240, 1000201, 1000506, 1000429, 1000857, 1000649, 1000898, 1000211, 1000000, 1000178, 1000038, 1000569, 1000695, 1000451, 1000159, 1000038, 1000038, 1000038, 1000129, 1000038, 1000038, 1000904, 1000038, 1000038, 1000902, 1000525, 1000038, 1000166, 1000038, 1000765, 1000038, 1000561, 1000417, 1000523, 1000668, 1000296, 1000038, 1000038, 1000038, 1000461, 1000654, 1000924, 1000985, 1000038, 1000426, 1000038, 1000038, 1000038, 1000904, 1000775, 1000148, 1000961, 1000038, 1000038, 1000038, 1000833, 1000332, 1000038, 1000038, 1000512, 1000322, 1000592, 1000524, 1000788, 1000057, 1000497, 1000625, 1000599, 1000484, 1000038, 1000747, 1000457, 1000111, 1000038, 1000038, 1000493, 1000287, 1000007, 1000695, 1000344, 1000098, 1000038, 1000191, 1000038, 1000576, 1000481, 1000488, 1000199, 1000038, 1000663, 1000176, 1000038, 1000521, 1000721, 1000728, 1000247, 1000038, 1000038, 1000460, 1000644, 1000038, 1000497, 1000966, 1000431, 1000038, 1000975, 1000063, 1000580, 1000669, 1000038, 1000038, 1000492, 1000038, 1000038, 1000529, 1000553, 1000333, 1000038, 1000341, 1000569, 1000862, 1000017, 1000532, 1000571, 1000508, 1000402, 1000285, 1000611, 1000210, 1000646, 1000110, 1000038, 1000553, 1000273, 1000729, 1000038, 1000038, 1000720, 1000400, 1000038, 1000983, 1000038, 1000766, 1000038, 1000180, 1000494, 1000765, 1000136, 1000038, 1000029, 1000246, 1000991, 1000038, 1000759, 1000038, 1000038, 1000045, 1000038, 1000648, 1000038, 1000038, 1000694, 1000914, 1000990, 1000038, 1000038, 1000758, 1000435, 1000038, 1000554, 1000038, 1000452, 1000156, 1000038, 1000322, 1000828, 1000868, 1000038, 1000973, 1000991, 1000464, 1000294, 1000633, 1000038, 1000582, 1000229, 1000285, 1000038, 1000038, 1000086, 1000038, 1000989, 1000038, 1000038, 1000157, 1000307, 1000369, 1000300, 1000038, 1000038, 1000038, 1000244, 1000038, 1000038, 1000222, 1000458, 1000038, 1000523, 1000434, 1000316, 1000038, 1000256, 1000038, 1000695, 1000038, 1000469);
        HashMap<Integer, Integer> occu = new HashMap<Integer, Integer>();
        int maxC = 0;
        int maxKey = 0;
        for (Integer k : ll) {
            if (occu.containsKey(k)) {
                occu.put(k, occu.get(k) + 1);
            } else {
                occu.put(k, 1);
            }
            if (occu.get(k) > maxC) {
                maxC = occu.get(k);
                maxKey = k;
            }
        }
        System.out.println("mC:" + maxC + ", mK:" + maxKey + ", len:" + ll.size() + ", tg:" + (ll.size() / 3));
        System.out.println(repeatedNumber(ll));
        System.out.println(repeatedNumberNew(ll));
    }

    public static int maximumGap(final int[] A) {
        if (A.length == 1) {
            return 0;
        }
        if (A.length == 2) {
            return (int) Math.abs(A[0] - A[1]);
        }

        int numBuckets = A.length;
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;

        for (int i : A) {
            if (i < min) {
                min = i;
            }
            if (i > max) {
                max = i;
            }
        }

        int range = (max - min) / numBuckets;

        if (numBuckets * range <= (max - min)) {
            range++;
        }

        int[][] map = new int[numBuckets][2];
        for (int i : A) {
            int bucket = (i - min) / range;
            if (map[bucket][0] == 0 && map[bucket][1] == 0) {
                map[bucket][0] = i;
                map[bucket][1] = i;
            }
            if (i < map[bucket][0]) {
                map[bucket][0] = i;
            }
            if (i > map[bucket][1]) {
                map[bucket][1] = i;
            }
        }

        int maxDiff = Integer.MIN_VALUE;
        int[] prev = map[0];
        for (int i = 1; i < numBuckets; i++) {
            if (map[i][0] != 0 && map[i][1] != 0) {
                int diff = map[i][0] - prev[1];
                if (diff > maxDiff) {
                    maxDiff = diff;
                }
                prev = map[i];
            }
        }

        return maxDiff;
    }

    public static void main(String[] args) {
//        int[] kN = new int[]{1,2,3,4,5,6,7,8,9,10};
//        int[] kN = new int[]{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10};

//        int[] kN = new int[]{658, 786, 531, 47, 169, 397, 914};
        //9140

//        int[] kN = new int[]{640, 435, 647, 352, 8, 90, 960, 329, 859};
        //17220

//        int[] kN = new int[]{449, 792, 564, 261, 584, 798, 514, 616};
//        2, 10, 25120

//        int[] kN = new int[]{452, 305, 314, 443, 826, 163, 433, 51, 372};
//        7,10,8260

//        int[] kN = new int[]{12, 34, 67, 90};
//        2, 113

//        int[] kN = new int[]{73, 58, 30, 72, 44, 78, 23, 9};
//        5,110

//        int[] kN = new int[]{87, 3, 27, 29, 40, 12, 3, 69, 9, 57, 60, 33, 99};
//        3,192

//        int[] kN = new int[]{97, 26, 12, 67, 10, 33, 79, 49, 79, 21, 67, 72, 93, 36, 85, 45, 28, 91, 94, 57, 1, 53, 8, 44, 68, 90, 24};
//        26, 97

        int[] kN = new int[]{2,3,3};

        ArrayList<Integer> kNAr = new ArrayList<Integer>();
        for (int i : kN) {
            kNAr.add(i);
        }
//        System.out.println(books(kNAr,26));
        int[] kNLoc = new int[]{2,1,4,1,2,2,5};
        ArrayList<ArrayList<Integer>> k =new ArrayList<ArrayList<Integer>>();
        for (int i : kNLoc) {
            ArrayList<Integer> loc = new ArrayList<Integer>();
            loc.add(i);
            k.add(loc);
        }


        System.out.println(new App().findMedian(k));
    }
    public int numLessThankS(ArrayList<Integer> A,int k){
        int low=0;
        int high=A.size()-1;
        int ans=-1;
        while(low<=high){
            int mid=low+(high-low)/2;
            int midVal=A.get(mid);
            if(midVal<=k ){
                if(mid==0 && midVal==k){
                    ans=-1;
                    break;
                }
                if( mid!=A.size()-1 && A.get(mid+1)>=k){
                    ans=mid;
                    break;
                }
                if( midVal<=k && mid==A.size()-1){
                    ans=mid;
                    break;
                }
                low=mid+1;
            }else{
                high=mid-1;
            }
        }
        return ans+1;
    }
    public int numLessThanK2(ArrayList<ArrayList<Integer>> A,int k){
        int count =0;
        for(ArrayList<Integer> row:A){
            count+=numLessThankS(row,k);
        }
        return count;
    }

    public int findK(ArrayList<Integer> A,int k){
        int low=0;
        int high=A.size()-1;
        while(low<=high){
            int mid=low+(high-low)/2;
            int midVal=A.get(mid);
            if(midVal==k ){
                return midVal;
            }else if(midVal<k){
                low=mid+1;
            }else{
                if(mid!=0 && A.get(mid-1)<k){
                    return midVal;
                }
                high=mid-1;
            }
        }
        if(k<A.get(0)){
            return A.get(0);
        }
        return Integer.MIN_VALUE;
    }

    public int ifKThenKElseMoreThanK(ArrayList<ArrayList<Integer>> A,int k){
        int found =Integer.MAX_VALUE;
        for(ArrayList<Integer> row:A){
            int foundLocal=findK(row,k);
            if(foundLocal==k){
                return k;
            }

            if(foundLocal>Integer.MIN_VALUE && foundLocal<found){
                found=foundLocal;
            }
        }
        return found;
    }

    public int findMedian(ArrayList<ArrayList<Integer>> A) {
        if(A==null ||A.size()==0 || A.get(0).size()==0){
            return -1;
        }
        int rowNum=A.size();
        int colNum=A.get(0).size();
        int target=rowNum*colNum/2;

        int low=Integer.MAX_VALUE;
        int high=Integer.MIN_VALUE;
        for(int i=0;i<rowNum;i++){
            if(A.get(i).get(0)<low){
                low=A.get(i).get(0);
            }
            if(A.get(i).get(colNum-1)>high){
                high=A.get(i).get(colNum-1);
            }
        }

        while(low<=high){
            int mid=low+(high-low)/2;
            int count=numLessThanK2(A,mid);
            if(count==target){
                //check if mid is part of array, else elem just bigger than array
                return ifKThenKElseMoreThanK(A,mid);
            }else if(count<target){
                low=mid+1;
            }else{
                high=mid-1;
            }
        }

        return A.get(rowNum/2).get(colNum/2);
    }

    public static long isPossible(ArrayList<Integer> books,int B, long taken){

        long sumTillNow=0;
        long max=Long.MIN_VALUE;
        for(int i=0;i<books.size();i++){
            if(sumTillNow+books.get(i)<=taken){
                sumTillNow+=books.get(i);
                if(sumTillNow>max){
                    max=sumTillNow;
                }
            }else {
                sumTillNow=0;
                B--;
                i--;
            }
            if(B==0 && i<books.size()){
                return Long.MIN_VALUE;
            }

        }
        if(B==1 && sumTillNow<=taken){
            if(sumTillNow>max){
                max=sumTillNow;
            }
            return max;
        }
        return Long.MAX_VALUE;
    }
    public static int books(ArrayList<Integer> A, int B) {

        if(B>A.size()){
            return -1;
        }

        ArrayList<Long> sum=new ArrayList<Long> ();
        long sumTN=0;
        long max=Long.MIN_VALUE;
        for(Integer c:A){
            sumTN+=c;
            sum.add(sumTN);
            if(c>max){
                max=c;
            }
        }

        if(B==A.size()){
            return (int)max;
        }

        long low=sum.get(0);
        long high=sum.get(A.size()-B);
        long min=Long.MAX_VALUE;
        while(low<=high){
            long mid=low+(high-low)/2;
            long possib=isPossible(A,B,mid);
            if(possib>Long.MIN_VALUE && possib<Long.MAX_VALUE){
                if(possib<min){
                    min=possib;
                }
                high=mid-1;
//                return (int) possib;
            }else if(possib==Long.MIN_VALUE ){
                low=mid+1;
            }else {
                high=mid-1;
            }
        }
        return (int)min;
    }

    public static int paint(int A, int B, ArrayList<Integer> C) {

        if(A>C.size()){
            A=C.size();
        }

        ArrayList<Long> sums=new ArrayList<Long> ();
        long sumTillNow=0;
        long sumMax=0;
        int modBase=10000003;
        int maxTillNow=0;

        for(Integer i:C){
            sumTillNow+=i;
            sums.add(sumTillNow);
            if(sumTillNow>sumMax){
                sumMax=sumTillNow;
            }
            if(i>maxTillNow){
                maxTillNow=i;
            }
        }

        if(A==1){
            return (int)(((sumMax%modBase)*B)%modBase);
        }
        if(A==C.size()){
            return (int)(((maxTillNow%modBase)*B)%modBase);
        }

        long maxTimeTaken=Long.MIN_VALUE;
        long sumGone=0;
        int lowPrev=-1;
        long targetSum=(sumMax)/A;
        for(int i=A;i>0;i--){

            int low=lowPrev+1;
            int high=sums.size()-1;
            int index=-1;
            while(low<=high && i!=1){
                int mid=low+(high-low)/2;
                long sumTobe=sums.get(mid) -sumGone ;
                if(sumTobe==targetSum){
                    index=mid;
                    break;
                }else if(mid!=sums.size()-1 &&
                        sums.get(mid)-sumGone<targetSum && targetSum<sums.get(mid+1)-sumGone){
                    index=mid;
                    if(Math.abs(targetSum -sums.get(mid))>Math.abs(sums.get(mid+1)-targetSum)){
                        index=mid+1;
                    }
                    break;
                }else if(sumTobe <targetSum){
                    low=mid+1;
                }else{
                    high=mid-1;
                }
            }

            if (index<0){
                index=lowPrev+1;
            }
            long sum=sums.get(index);
            if(i==1){
             sum=sums.get(sums.size()-1);
            }
            if( ((((sum-sumGone)%modBase)*B)%modBase)>maxTimeTaken){
                maxTimeTaken=((((sum-sumGone)%modBase)*B)%modBase);
            }
            sumGone=sum;
            lowPrev=index;
        }

        return (int)(maxTimeTaken%modBase);

    }

    public static ArrayList<Integer> searchRange(final List<Integer> a, int b) {
        int low=0;
        int high=a.size()-1;

        boolean LI=false;
        int lIndex=-1;
        boolean HI=false;
        int hIndex=-1;

        ArrayList<Integer> res=new ArrayList<Integer>();

        while(low<=high){
            int midLI=low+(high-low)/2;
            if(a.get(midLI)==b && (midLI==0 || a.get(midLI-1)!=b)){
                LI=true;
                lIndex=midLI;
                break;
            }else if(a.get(midLI)>b ||
                    (a.get(midLI)==b && midLI!=0 && a.get(midLI-1)==b)){
                high=midLI-1;
            }else{
                low=midLI+1;
            }
        }
        if(!LI){
            res.add(lIndex);
            res.add(hIndex);
            return res;
        }
        low=lIndex;
        high=a.size()-1;

        while(low<=high){
            int midLI=low+(high-low)/2;
            if(a.get(midLI)==b && (midLI==a.size()-1 || a.get(midLI+1)!=b)){
                HI=true;
                hIndex=midLI;
                break;
            }else if(a.get(midLI)<b ||
                    (a.get(midLI)==b && midLI!=a.size()-1 && a.get(midLI+1)==b )){
                low=midLI+1;
            }else{
                high=midLI-1;
            }
        }

        res.add(lIndex);
        res.add(hIndex);
        return res;

    }

    public int searchMatrix(ArrayList<ArrayList<Integer>> a, int b) {

        if(a==null || a.size()==0 || a.get(0).size()==0){
            return 0;
        }
        int rowMax=a.size();
        int colMax=a.get(0).size();
        int colMin=0;
        int rowMin=0;
        //edges

        //find closestLow in first row
        int low=rowMin;int high=rowMax;
        int targRow=-1,targCol=-1;
        //find target row,col
        while(low<=high){
            int midRow=low+(high-low)/2;
            if(a.get(midRow).get(colMin)<=b && a.get(midRow).get(colMax)>=b){
                targRow=midRow;
                break;
            }else if(a.get(midRow).get(0)>b){
                //less
                high=midRow-1;
            }else if(a.get(midRow).get(colMax)<b){
                //more
                low=midRow+1;
            }
        }
        if(targRow==-1){
            return 0;
        }

        low=colMin;
        high=colMax;

        while(low<=high){
            int mid=low+(high-low)/2;
            int midVal=a.get(targRow).get(mid);
            if(midVal==b){
                targCol=mid;
                break;
            }else if(midVal<b){
                    low=mid+1;
	            }else{
                high=mid-1;
            }
        }
        if(targCol>=0){
            return 1;
        }

        return 0;
    }

    public static int pow(int x, int n, int d) {
        if(n==0){
            if(x==0){
                return 0;
            }
            return 1;
        }

        //        x=x%d;

        long res=Math.abs(x);
        long extra=1;
        long sign=1;

        if(n%2==1){
            n=n-1;
            if(x<0){
                sign=-1;
            }
            extra=res;
        }


        while(n>1){
            res=((res%d)*(res%d))%d;
            n=n/2;
        }
        res=((res%d)*(extra%d))%d;
        int ans=(int)(sign*res);

        if(ans<0){
            return ans+d;
        }
        return ans;
    }

    public static int sqrt(int a) {

        if(a==0){
            return a;
        }

        long prev=1;
        long curr=2;
        while(curr*curr <a){
            prev=curr;
            curr *=2;
        }

        //bin search
        while(prev<curr){
            //edges
            if(prev*prev<=a && (prev+1)*(prev+1)>a){
                return (int)prev;
            }
            if(curr*curr==a){
                return (int)curr;
            }
            if(curr*curr<a && (curr-1)*(curr-1)>a){
                return (int)curr-1;
            }

            long mid= prev+(curr-prev)/2;

            if(mid*mid>a && (mid-1)*(mid-1)<=a) {
                return (int) mid-1;
            }
            if(mid*mid<=a && (mid+1)*(mid+1)>a){
                return (int)mid;
            }
            if((mid+1)*(mid+1)==a){
                return (int)mid+1;
            }

            if(mid*mid<a){
                prev=mid+1;
            }else{
                curr=mid-1;
            }
        }
        return -1;
    }

    public static HashMap<Character,Integer> uniqNumLessThan(List<Character> list,char k){
        HashMap<Character,Integer> uniq=new HashMap<Character,Integer> ();
        for(Character c:list){
            if(c.equals(k)){
                break;
            }
            if(uniq.containsKey(c)){
                uniq.put(c,uniq.get(c)+1);
            }else{
                uniq.put(c,1);
            }
        }
        return uniq;
    }

    public static int nFact(int k){
        if(k==0){
            return 0;
        }
        int modBase=1000003;

        int fact=1;
        for(int i=2;i<=k;i++){
            fact= ((fact%modBase)*i)%modBase;
        }
        return fact%modBase;
    }

    public static int modInverse(int a, int m)
    {
        a = a % m;
        for (int x = 1; x < m; x++)
            if ((a * x) % m == 1)
                return x;
        return 1;
    }

    public static int findRankRep(String A) {
        if(A==null || A.length()<=1){
            return 1;
        }

        List<Character> orig=new LinkedList<Character> ();
        List<Character> sorted=new LinkedList<Character> ();
        HashMap<Character,Integer> counts=new HashMap<Character,Integer>();
        for(char c:A.toCharArray()){
            orig.add(c);
            sorted.add(c);
            if(counts.containsKey(c)){
                counts.put(c,counts.get(c)+1);
            }else {
                counts.put(c,1);
            }
        }
        Collections.sort(sorted);
        long res=0;
        int modBase=1000003;

        for(int i=0;i<orig.size();i++){
            if(orig.get(i)==sorted.get(i)){
                if(counts.get(orig.get(i))==1){
                    counts.remove(orig.get(i));
                }else {
                    counts.put(orig.get(i),counts.get(orig.get(i))-1);
                }
                orig.remove(i);
                sorted.remove(i);
                i--;
            }else{
                int indexSorted=sorted.indexOf(orig.get(i));
                HashMap<Character,Integer> uniq=uniqNumLessThan(sorted,orig.get(i));
                int numLessThanChar=indexSorted;
                int restPossib=nFact(orig.size()-1);
                int div=1;

                for(Map.Entry<Character,Integer> e:counts.entrySet()){

                    div=((div%modBase)*(nFact(e.getValue())%modBase))%modBase;
                }

                int divMod=modInverse(div ,modBase ) % modBase;

                res = (res + (((numLessThanChar * restPossib%modBase)*divMod%modBase))%modBase )%modBase;

                if(counts.get(orig.get(i))==1){
                    counts.remove(orig.get(i));
                }else {
                    counts.put(orig.get(i),counts.get(orig.get(i))-1);
                }

                orig.remove(i);
                sorted.remove(indexSorted);
                i--;

            }
        }
        return ((int)res%modBase+1)%modBase;
    }

    public static int gcd(int A,int B){
        if(A==1 || B==1){
            return 1;
        }

        if(A<B){
            int tmp=A;
            A=B;
            B=tmp;
        }
        if(A%B==0){
            return B;
        }

        return gcd(A%B,B);


    }
    public static int cpFact(int A, int B) {

        int gcdAB=gcd(A,B);

        if(gcdAB==1){
            return A;
        }

        return cpFact(A/gcdAB,B);

    }

    public static int numLessThanK(ArrayList<Integer> A, int k){
        int count=0;
        for(int i:A){
            if(i<k){
                count++;
            }else{
                break;
            }
        }
        return count;
    }

    public static int solve(ArrayList<Integer> A, int B, int C) {

        int numDigits=(int)Math.log10(C)+1;

        if(B<numDigits){
            if(A.indexOf(0)>=0 && B!=1){
                return (A.size()-1)*(int)Math.pow(A.size(),B-1);
            }
            return (int)Math.pow(A.size(),B);
        }

        if(B>numDigits){
            return 0;
        }

        int res=0;
        //equals case
        for(int i=B;i>0;i--){
            int msd=C/(int)Math.pow(10,i-1);
            int numLessThanMsdCount=numLessThanK(A,msd);
//            if(numLessThanMsdCount==0){
//                break;
//            }
            if(A.indexOf(0)>=0){
                if(B!=1 && i==B){
                    res+= (numLessThanMsdCount-1)*Math.pow(A.size(),i-1);
                }else{
                    res+= (numLessThanMsdCount)*Math.pow(A.size(),i-1);
                }

            }else{
                res+= (numLessThanMsdCount)*Math.pow(A.size(),i-1);
            }
            if(A.indexOf(msd)<0){
                break;
            }
            C = C%((int)Math.pow(10,i-1));
        }
        return res;
    }

    public static int factorialMod(int a){
        if(a==0){
            return 0;
        }
        int modBase=1000003;
        int res=1;
        for(int i=a;i>1;i--){
            res= ((res%modBase)*(i%modBase))%modBase;
        }
        return res%modBase;
    }

    public static int findRank(String A) {
        if(A==null){
            return 0;
        }
        int modBase=1000003;
        List<Character> orig=new LinkedList<Character>();
        List<Character> sorted=new LinkedList<Character>();
        for(char a:A.toCharArray()){
            sorted.add(a);
            orig.add(a);
        }

        Collections.sort(sorted);

        int res=0;

        for(int i=0;i<orig.size();i++){
            char ch=orig.get(i);
            int index=sorted.indexOf(ch);
            res = (res%modBase+ index*factorialMod(sorted.size()-1)%modBase)%modBase;
            sorted.remove(index);
        }
        return (res%modBase+1)%modBase;
    }

    public static void arrange(ArrayList<Integer> a) {
        if (a == null || a.size() == 0) {
            return;
        }
        int len = a.size();
        int zeroIndex = -1;
        for (int i = 0; i < a.size(); i++) {
            int index = a.get(i);
            if (index == 0) {
                zeroIndex = i;
            }
            if (index != i && index != zeroIndex) {
                int replacement = a.get(index % len) / len;
                if (a.get(index % len) < len) {
                    replacement = a.get(index % len);
                }
                a.set(i, index * len + replacement);
            }
            if (index == zeroIndex) {
                a.set(i, index * len);
            }
        }

        //reajust

        for (int i = 0; i < a.size(); i++) {
            int index = a.get(i);
            a.set(i, index % len);
        }

    }

    public static int reverse(int A) {
        int mul = 1;
        if (A < 0) {
            mul = -1;
            A = A * -1;
        }
        int rev = 0;
        while (A > 9) {
            if (rev > (Integer.MAX_VALUE - A % 10) / 10) {
                return 0;
            }
            rev = rev * 10 + A % 10;
            A = A / 10;
        }
        if (rev > (Integer.MAX_VALUE - A % 10) / 10) {
            return 0;
        }
        rev = rev * 10 + A;
        return rev * mul;
    }

    public static int isPalindrome(int A) {
        if (A < 0) {
            return 0;
        }
        if (A < 10) {
            return 1;
        }
        int digits = (int) Math.log10(A) + 1;

        int count = 1;
        while (count <= digits / 2) {
            int lsd = A % ((int) Math.pow(10, count));
            lsd = lsd / ((int) Math.pow(10, count - 1));
            int msd = A / ((int) Math.pow(10, digits - count));
            msd = msd % 10;
            if (lsd != msd) {
                return 0;
            }
            count++;
        }
        return 1;
    }

    public static int isPower(int A) {
        if (A == 1) {
            return 1;
        }
        for (double i = 2.0; i < 200.0; i++) {
            double ith_root = Math.pow(A, 1.0 / i);
            if (ith_root < 1) {
                return 0;
            }
            double chck = Math.ceil(ith_root);
            if (Math.pow(chck, i) == (double) A) {
//                int regen=(int)Math.pow(ith_root,i);
//                System.out.println(i+","+regen+","+A+", "+ith_root);
                return 1;
            }
        }
        return 0;
    }

    public class customComparator implements Comparator<App> {
        public int compare(App o1, App o2) {
            return 0;
        }
    }

    public static boolean hotelMaaki(ArrayList<Integer> arrive, ArrayList<Integer> depart, int K) {
        Collections.sort(arrive, new Comparator<Integer>() {
            public int compare(Integer a, Integer b) {
                return a - b;
            }
        });

        return false;
    }

    public static boolean hotel(ArrayList<Integer> arrive, ArrayList<Integer> depart, int K) {
        if (arrive == null || depart == null || arrive.size() != depart.size()) {
            return false;
        }
        ArrayList<Integer> repre = new ArrayList<Integer>();

        ArrayList<Integer> tobe = new ArrayList<Integer>();

        for (int i = 0; i < arrive.size(); i++) {
            repre.add(i);
            tobe.add(arrive.get(i));
        }
        for (int i = 0; i < depart.size(); i++) {
            repre.add(arrive.size() + i);
            tobe.add(depart.get(i));
        }

        final ArrayList<Integer> array = new ArrayList<Integer>(tobe);

        // Collections.sort(repre,new SortbyArrival(tobe));
        Collections.sort(repre, new Comparator<Integer>() {
            public int compare(Integer c1, Integer c2) {
                if (array.get(c1) == array.get(c2)) {
                    return c2 - c1;
                }
                return array.get(c1) - array.get(c2);
            }
        });

        long[] bookings = new long[tobe.size()];

        for (int i = 0; i < repre.size(); i++) {
            int index = repre.get(i);
            if (index < arrive.size()) {
                bookings[i]++;
            } else {
                bookings[i]--;
            }
        }
        long sum = 0;
        for (int i = 0; i < bookings.length; i++) {
            sum += bookings[i];
            if (sum > K) {
                return false;
            }
        }

        return true;

    }

    public int solve(ArrayList<String> A) {
        if (A == null || A.size() < 3) {
            return 0;
        }

        ArrayList<Float> b00_67 = new ArrayList<Float>();
        ArrayList<Float> b00_67_min = new ArrayList<Float>();
        ArrayList<Float> b00_67_max = new ArrayList<Float>();

        ArrayList<Float> b67_1 = new ArrayList<Float>();
        ArrayList<Float> b67_1_min = new ArrayList<Float>();
        ArrayList<Float> b67_1_max = new ArrayList<Float>();

        ArrayList<Float> b1_2 = new ArrayList<Float>();
        ArrayList<Float> b1_2_min = new ArrayList<Float>();
        ArrayList<Float> b1_2_max = new ArrayList<Float>();

        for (String s : A) {
            Float num = Float.parseFloat(s);
            ArrayList<Float> targeList = new ArrayList<Float>();
            ArrayList<Float> targeList_min = new ArrayList<Float>();
            ArrayList<Float> targeList_max = new ArrayList<Float>();
            if (num < 0.67) {
                targeList = b00_67;
                targeList_min = b00_67_min;
                targeList_max = b00_67_max;
            } else if (num >= 0.67 && num <= 1) {
                targeList = b67_1;
                targeList_min = b67_1_min;
                targeList_max = b67_1_max;
            } else {
                targeList = b1_2;
                targeList_min = b1_2_min;
                targeList_max = b1_2_max;
            }

            targeList.add(num);
            if (targeList_min.size() < 3) {
                targeList_min.add(num);
                Collections.sort(targeList_min);
            } else {
                for (int i = 0; i < targeList_min.size(); i++) {
                    if (num <= targeList_min.get(i)) {
                        targeList_min.add(i, num);
                        targeList_min.remove(targeList_min.size() - 1);
                    }
                }
            }
            if (targeList_max.size() < 3) {
                targeList_max.add(num);
                Collections.sort(targeList_max, Collections.reverseOrder());
            } else {
                for (int i = 0; i < targeList_max.size(); i++) {
                    if (num >= targeList_max.get(i)) {
                        targeList_max.add(i, num);
                        targeList_max.remove(targeList_max.size() - 1);
                    }
                }
            }
        }

        //AAA
        float actSum = 0;
        if (b00_67_max.size() == 3) {
            for (int i = 0; i < b00_67_max.size(); i++) {
                actSum += b00_67_max.get(i);
            }
            if (actSum > 1 && actSum < 2) {
                return 1;
            }
        }


        //AAB
        actSum = 0;
        if (b00_67_max.size() >= 2) {
            if (b67_1_min.size() >= 1) {
                actSum = b00_67_max.get(0) + b00_67_max.get(1) + b67_1_min.get(0);
                if (actSum > 1 && actSum < 2) {
                    return 1;
                }
            }
            if (b67_1_max.size() >= 1) {
                actSum = b00_67_max.get(0) + b00_67_max.get(1) + b67_1_max.get(0);
                if (actSum > 1 && actSum < 2) {
                    return 1;
                }
            }
        }
        if (b00_67_min.size() >= 2) {
            if (b67_1_min.size() >= 1) {
                actSum = b00_67_min.get(0) + b00_67_min.get(1) + b67_1_min.get(0);
                if (actSum > 1 && actSum < 2) {
                    return 1;
                }
            }
            if (b67_1_max.size() >= 1) {
                actSum = b00_67_min.get(0) + b00_67_min.get(1) + b67_1_max.get(0);
                if (actSum > 1 && actSum < 2) {
                    return 1;
                }
            }
        }

        //ABC
        actSum = 0;
        if (b00_67_min.size() >= 1 && b67_1_min.size() >= 1 && b1_2_min.size() >= 1) {
            actSum = b00_67_min.get(0) + b67_1_min.get(0) + b1_2_min.get(0);
            if (actSum > 1 && actSum < 2) {
                return 1;
            }
        }

        //AAC
        actSum = 0;
        if (b00_67_min.size() >= 2 && b1_2_min.size() >= 1) {
            actSum = b00_67_min.get(0) + b00_67_min.get(1) + b1_2_min.get(0);
            if (actSum > 1 && actSum < 2) {
                return 1;
            }
        }

        //BBA
        actSum = 0;
        if (b00_67_min.size() >= 1 && b67_1_min.size() >= 2) {
            actSum = b00_67_min.get(0) + b67_1_min.get(0) + b67_1_min.get(1);
            if (actSum > 1 && actSum < 2) {
                return 1;
            }
        }

        return 0;
    }

    public static void nextPermutation(ArrayList<Integer> a) {
        if (a == null || a.size() <= 1) {
            return;
        }
        ArrayList<Integer> bag = new ArrayList<Integer>();
        int maxTillNow = a.get(a.size() - 1);
        bag.add(a.get(a.size() - 1));
        a.remove(a.size() - 1);

        while (a.size() > 0) {
            int num = a.get(a.size() - 1);
            if (maxTillNow > num) {
                //magic;
                break;
            } else {
                bag.add(num);
                a.remove(a.size() - 1);
                if (num > maxTillNow) {
                    maxTillNow = num;
                }
            }
        }
        //let the magic begin
        if (a.size() != 0) {
            int numFlick = a.get(a.size() - 1);
            Collections.sort(bag);
            for (int i = 0; i < bag.size(); i++) {
                if (bag.get(i) > numFlick) {
                    //swap and return
                    a.set(a.size() - 1, bag.get(i));
                    bag.set(i, numFlick);
                    a.addAll(bag);
                    return;
                }
            }
        } else {
            a.addAll(bag);
        }
        return;
    }

    public static int firstMissingPositiveN(ArrayList<Integer> A) {
        if (A == null || A.size() == 0) {
            return 1;
        }
        int size = A.size();
        for (int i = 0; i < A.size(); i++) {
            if (A.get(i) < 0 || A.get(i) > size) {
                A.set(i, 0);
            }
        }

        for (int i = 0; i < A.size(); i++) {
            int tmp = A.get(i);
            if (tmp > 0) {
                if (A.get(tmp - 1) > 0) {
                    A.set(tmp - 1, -1 * A.get(tmp - 1));
                } else if (A.get(tmp - 1) == 0) {
                    A.set(tmp - 1, Integer.MIN_VALUE);
                }
            } else if (tmp != Integer.MIN_VALUE && tmp != 0) {
                tmp = -1 * tmp;
                if (A.get(tmp - 1) > 0) {
                    A.set(tmp - 1, -1 * A.get(tmp - 1));
                } else if (A.get(tmp - 1) == 0) {
                    A.set(tmp - 1, Integer.MIN_VALUE);
                }
            }
        }

        for (int i = 0; i < A.size(); i++) {
            if (A.get(i) >= 0) {
                return i + 1;
            }
        }
        return A.size() + 1;
    }

    public static ArrayList<Integer> maxset(ArrayList<Integer> A) {
        long maxSum = 0;
        ArrayList<Integer> maxList = new ArrayList<Integer>();
        int length = 0;
        int minSid = Integer.MAX_VALUE;
        if (A == null || A.size() == 0) {
            return maxList;
        }

        long localSum = 0;
        ArrayList<Integer> localMaxList = new ArrayList<Integer>();
        int localSid = Integer.MAX_VALUE;
        for (int i = 0; i < A.size(); i++) {
            if (A.get(i) >= 0) {
                if (i < localSid) {
                    localSid = i;
                }
                localSum += A.get(i);
                localMaxList.add(A.get(i));
            } else {
                if (localSum > maxSum) {
                    maxSum = localSum;
                    maxList = localMaxList;
                    minSid = localSid;
                } else if (localSum == maxSum) {
                    maxSum = localSum;
                    if (localMaxList.size() > maxList.size()) {
                        maxList = localMaxList;
                        minSid = localSid;
                    } else if (localMaxList.size() == maxList.size() && localSid < minSid) {
                        maxList = localMaxList;
                        minSid = localSid;
                    }
                }
                localSum = 0;
                localMaxList = new ArrayList<Integer>();
                localSid = Integer.MAX_VALUE;
            }
        }
        if (localSum > maxSum) {
            maxSum = localSum;
            maxList = localMaxList;
            minSid = localSid;
        } else if (localSum == maxSum) {
            maxSum = localSum;
            if (localMaxList.size() > maxList.size()) {
                maxList = localMaxList;
                minSid = localSid;
            } else if (localMaxList.size() == maxList.size() && localSid < minSid) {
                maxList = localMaxList;
                minSid = localSid;
            }
        }
        return maxList;
    }

    public static ArrayList<Long> getRow(int A) {

        ArrayList<Long> pascal = new ArrayList<Long>();
        if (A <= 0) {
            return pascal;
        }
        pascal.add(1l);
        if (A == 0) {
            return pascal;
        }
        pascal.add(1l);
        if (A == 1) {
            return pascal;
        }
        pascal = new ArrayList<Long>();
        for (int i = 0; i <= A; i++) {
            pascal.add((ncr(A, i)));
        }
        return pascal;
    }

    public static long ncr(int n, int r) {
        if (r > n / 2) {
            r = n - r;
        }
        long nfact = 1, rfact = 1;
        for (int i = 0; i < r; i++) {
            nfact *= (n - i);
            rfact *= (i + 1);
        }
        return nfact / rfact;
    }

    public static int maxArr(ArrayList<Integer> A) {
        if (A == null || A.size() <= 1) {
            return 0;
        }
        int[] lMax = new int[A.size()];
        int[] rMax = new int[A.size()];
        int[] lMin = new int[A.size()];
        int[] rMin = new int[A.size()];
        int min = 0;
        int max = 0;
        for (int i = 0; i < A.size(); i++) {
            int actMax = A.get(max);
            int actMin = A.get(min);
            if (A.get(i) + i > actMax + max) {
                max = i;
            }
            if (A.get(i) - i < actMin - min) {
                min = i;
            }
            lMax[i] = max;
            lMin[i] = min;
        }
        min = A.size() - 1;
        max = A.size() - 1;
        for (int i = A.size() - 1; i >= 0; i--) {
            int actMax = A.get(max);
            int actMin = A.get(min);
            if (A.get(i) + i > actMax + max) {
                max = i;
            }
            if (A.get(i) - i < actMin - min) {
                min = i;
            }
            rMax[i] = max;
            rMin[i] = min;
        }
        int allMax = Integer.MIN_VALUE;
        for (int i = 0; i < A.size(); i++) {

            int lMaRmi_Max = Math.abs(A.get(lMax[i]) - A.get(rMin[i]))
                    + Math.abs(lMax[i] - rMin[i]);
            int lMiRma_Max = Math.abs(A.get(lMin[i]) - A.get(rMax[i]))
                    + Math.abs(lMin[i] - rMax[i]);
            int localMax = Math.max(lMaRmi_Max, lMiRma_Max);
            allMax = Math.max(localMax, allMax);
        }
        return allMax;
    }

    public static int maximumGap(final List<Integer> A) {
        ArrayList<Integer> indexList = new ArrayList<Integer>();
        int[] maxDistList = new int[A.size()];
        for (int i = 0; i < A.size(); i++) {
            indexList.add(i);
        }
        //sort them indexList using A.
        Collections.sort(indexList, new Comparator<Integer>() {
            public int compare(Integer c1, Integer c2) {
                return A.get(c1) - A.get(c2);
            }
        });
        //fill in them maxDistList
        int maxIndex = Integer.MIN_VALUE; // -Infinity
        int max = Integer.MIN_VALUE; // -Infinity

        for (int i = maxDistList.length - 1; i >= 0; i--) {
            maxDistList[i] = Math.max(maxIndex, indexList.get(i));
            maxIndex = maxDistList[i];
            if ((maxDistList[i] - indexList.get(i)) > max) {
                max = maxDistList[i] - indexList.get(i);
            }
        }
        return max;
    }


    //      Definition for an interval.
    public static class Interval {
        int start;
        int end;

        Interval() {
            start = 0;
            end = 0;
        }

        Interval(int s, int e) {
            start = s;
            end = e;
        }
    }

    class IntervalComparator implements Comparator<Interval> {
        public int compare(Interval c1, Interval c2) {
            if (c1.start == c2.start) {
                return c1.end - c2.end;
            }
            return c1.start - c2.start;
        }
    }

    public static ArrayList<Interval> merge(ArrayList<Interval> intervals) {
        if (intervals == null || intervals.size() < 2) {
            return intervals;
        }

        // Collections.sort(intervals,new IntervalComparator());
        Collections.sort(intervals, new Comparator<Interval>() {
            public int compare(Interval c1, Interval c2) {
                if (c1.start == c2.start) {
                    return c1.end - c2.end;
                }
                return c1.start - c2.start;
            }
        });

        for (Interval l : intervals) {
            System.out.println("s: " + l.start + ", e: " + l.end);
        }

        Interval latest = intervals.get(0);
        intervals.remove(0);
        for (int i = 0; i < intervals.size(); i++) {
            Interval curr = intervals.get(i);
            System.out.println("ls: " + latest.start + ", le: " + latest.end + ", cs:" + curr.start + ", ce:" + curr.end);
            if (latest.end < curr.start) {
                intervals.add(i, latest);
                latest = curr;
            } else if (latest.start <= curr.end) {
                Interval newLatest = new Interval(
                        Math.min(latest.start, curr.start),
                        Math.max(latest.end, curr.end)
                );
                intervals.remove(i);
                i--;
                latest = newLatest;
            }
        }

        if (intervals.size() > 0) {
            Interval last = intervals.get(intervals.size() - 1);
            if (last.end < latest.start) {
                intervals.add(latest);
            }
        } else {
            intervals.add(latest);
        }
        return intervals;
    }

    public static int firstMissingPositive(ArrayList<Integer> A) {
        for (int i = 0; i < A.size(); i++) {
            if (A.get(i) < 0 || A.get(i) > A.size()) {
                A.set(i, 0);
            }
        }
        for (int i = 0; i < A.size(); i++) {
            int tmp = A.get(i);
            if (tmp > 0) {
                if (A.get(tmp - 1) > 0) {
                    A.set(tmp - 1, -1 * A.get(tmp - 1));
                } else if (A.get(tmp - 1) == 0) {
                    A.set(tmp - 1, -1 * (i + 1));
                }
            } else {
                if (tmp != 0) {
                    tmp = -1 * tmp;
                    if (A.get(tmp - 1) > 0) {
                        A.set(tmp - 1, -1 * A.get(tmp - 1));
                    } else if (A.get(tmp - 1) == 0) {
                        A.set(tmp - 1, -1 * (i + 1));
                    }
                }
            }
        }

        for (int i = 0; i < A.size(); i++) {
            if (A.get(i) >= 0) {
                return i + 1;
            }
        }
        return A.size() + 1;

    }

    public static ArrayList<Integer> repeatedNumber2(final List<Integer> A) {

        if (A == null || A.size() == 0) {
            return null;
        }

        int xorCalc = 0;
        int xorAct = 0;

        for (int i = 1; i <= A.size(); i++) {
            xorCalc ^= i;
            xorAct ^= A.get(i - 1);
        }
        int A_xor_B = xorCalc ^ xorAct;
        int A1 = 0;
        int B1 = 0;
        ArrayList<Integer> res = new ArrayList<Integer>();
        int set_bit_no = A_xor_B & ~(A_xor_B - 1);

        for (int i = 0; i < A.size(); i++) {
            if ((A.get(i) & set_bit_no) != 0)
                /* arr[i] belongs to first set */
                A1 = A1 ^ A.get(i);

            else
                /* arr[i] belongs to second set*/
                B1 = B1 ^ A.get(i);
        }
        for (int i = 1; i <= A.size(); i++) {
            if ((i & set_bit_no) != 0)
                /* arr[i] belongs to first set */
                A1 = A1 ^ i;

            else
                /* arr[i] belongs to second set*/
                B1 = B1 ^ i;
        }
        int countA1 = 0;
        for (int i = 0; i < A.size(); i++) {
            if (A.get(i) == A1) {
                countA1++;
            }
        }
        if (countA1 == 2) {
            res.add(A1);
            res.add(B1);
        } else {
            res.add(B1);
            res.add(A1);
        }

        return res;

    }

    public static ArrayList<Integer> flip(String A) {
        ArrayList<Integer> res = new ArrayList<Integer>();
        String[] Arr = A.split("");
        int[] ArrCounts = new int[Arr.length];
        int actNum1 = 0;
        for (int i = 0; i < Arr.length; i++) {
            if (Arr[i].equals("1")) {
                actNum1++;
            }
        }
        int maxNum1 = actNum1;
        int maxNum1TillNow = actNum1;
        for (int i = 0; i < Arr.length; i++) {
            if (Arr[i].equals("0")) {
                if (maxNum1TillNow < actNum1) {
                    maxNum1TillNow = actNum1;
                }
                maxNum1TillNow++;
                if (maxNum1TillNow > maxNum1) {
                    maxNum1 = maxNum1TillNow;
                }
            } else {
                maxNum1TillNow--;
            }
            ArrCounts[i] = maxNum1TillNow;
        }
        int start = -1;
        int end = -1;
        for (int i = 0; i <= ArrCounts.length - 1; i++) {
            if (ArrCounts[i] == maxNum1 && end == -1) {
                end = i + 1;
            }
        }
        for (int i = end - 1; i >= 0; i--) {
            if (ArrCounts[i] == actNum1 + 1) {
                start = i + 1;
                if (i > 0 && ArrCounts[i - 1] < actNum1) {
                    break;
                }
            }
        }

        if (start == -1 && end == -1) {
            return res;
        } else {
            res.add(start);
            res.add(end);
        }
        return res;
    }

    public static int[][] generate2(int A) {
        if (A < 0) {
            return null;
        }
        int[][] pascal = new int[A][A];
        if (A == 0) {
            return pascal;
        }
        // pascal[0]=new int[] {1};
        pascal[0][0] = 1;
        if (A == 1) {
            return pascal;
        }
        // pascal[1]=new int[] {1,1};
        pascal[1][0] = 1;
        pascal[1][1] = 1;
        if (A == 2) {
            return pascal;
        }
        int[] prev = pascal[1];
        for (int i = 2; i < A; i++) {
            pascal[i] = new int[i + 1];
            pascal[i][0] = 1;
            pascal[i][i] = 1;
            for (int j = 1; j < i; j++) {
                pascal[i][j] = prev[j - 1] + prev[j];
            }
            prev = pascal[i];
        }
        return pascal;
    }

    public static int[][] generate(int A) {
        if (A < 0) {
            return null;
        }
        int[][] pascal = new int[A][];
        if (A == 0) {
            return pascal;
        }
        pascal[0] = new int[]{1};
        if (A == 1) {
            return pascal;
        }
        pascal[1] = new int[]{1, 1};
        if (A == 2) {
            return pascal;
        }
        int[] prev = pascal[1];
        for (int i = 2; i < A; i++) {
            pascal[i] = new int[prev.length + 1];
            pascal[i][0] = 1;
            pascal[i][pascal[i].length - 1] = 1;
            for (int j = 1; j < prev.length; j++) {
                pascal[i][j] = prev[j - 1] + prev[j];
            }
            prev = pascal[i];
        }
        return pascal;
    }

    void start2() {
        long[] a1 = {3, 4, 5};
        long[] a2 = fix(a1);
        System.out.print(a1[0] + a1[1] + a1[2] + " ");
        System.out.println(a2[0] + a2[1] + a2[2]);
    }

    long[] fix(long[] a3) {
        a3[1] = 7;
        return a3;
    }

    void start() {
        String s1 = "slip";
        String s2 = fix(s1);
        System.out.println(s1 + " " + s2);
    }

    String fix(String s1) {
        s1 = s1 + "stream";
        System.out.print(s1 + " ");
        return "stream";
    }

}
